#!/usr/bin/zsh

autoload -U regexp-replace

BIN_DIR=/usr/local/bin
SCRIPT_DIR=${0:a:h}
UPGRADED=0
INSTALLED_PACKAGES=()
PACKAGE_INSTALATION=0
FAILED_PACKAGES=()

NEOVIM_DOWNLOAD_URL="https://github.com/neovim/neovim/releases/latest/download"

__NVIM_SHARE=$HOME/.local/share/nvim
__NVIM_BRICKS=$__NVIM_SHARE/bricks

__PERL_HOME=$__NVIM_BRICKS/perl5
__NODE_HOME=$__NVIM_BRICKS/node
__CARGO_HOME=$__NVIM_BRICKS/cargo
__PYTHON_HOME=$__NVIM_BRICKS/python
__LUA_HOME=$__NVIM_BRICKS/lua

__PERL_LIB=$__PERL_HOME/lib/perl5
__CARGO_BIN=$__CARGO_HOME/bin



#############################################
# init functions
#
init_colors(){
	r='[31m'
	g='[32m'
	y='[33m'
	b='[34m'
	m='[35m'
	c='[36m'
	w='[37m'
	n='[0m'

	if [[ $(tput colors) -lt 256 ]]; then
		s='[90m'
	else
		s='[38;5;243m'
	fi
}

check_if_root(){
	[[ $EUID -ne 0 ]] && return
	[[ -z $SUDO_USER ]] && return

	cat <<-EOF
		${y}
		   Run this script as regular user. DO NOT use sudo!
		${n}
	EOF

	exit 1
}


#############################################
# main functions
#
exec_help(){
	init_colors

	cat <<-EOF

		   ${w}usage:${n}
		      install COMMAND

		   ${w}commands:${n}
		      neovim     - install latest neovim
		      packages   - install other programs/modules (nodejs, ruby,
		                   perl, pynvim, ruby nvim, rust, ...)

		      all        - run all the above in single run

	EOF
}

exec_all(){
	INSTALL_ALL=yes

	install_packages
	install_neovim
}

exec_neovim(){
	install_neovim $@
}

exec_packages(){
	install_packages
}

install_neovim(){
	local app
	local pkg=deb

	case $pkg in 
		app) app=nvim.appimage
			 ;;
		deb) app=nvim
			 ;;
	esac

	if [[ -z $app ]]; then

		cat <<-EOF | alert_box --left
			${y}
			  Give package type you want to install:
			
			    ${w}app${y}   - install appImage
			    ${w}deb${y}   - install debian package
			${n}
		EOF

		exit 1
	fi


	local is_installed=$(hash $app 2>/dev/null; echo $?)

	if [[ $is_installed -eq 0 ]] && [[ ${+INSTALL_ALL} -eq 1 ]]; then
		cat <<-EOF | alert_box 
		
			Neovim already installed.

			To install it again run: ${w}install-debian neovim${n}
			${n}
		EOF

		return
	fi >&2


	case $pkg in
		app) download_appimage
			 register_neovim_app nvim.appimage vi  N
			 register_neovim_app nvim.appimage vim Y
			 ;;
		deb) download_deb_pkg
			 register_neovim_app nvim vi  N
			 register_neovim_app nvim vim Y
			 ;;
	esac

	echo
}

load_package_list(){
	typeset -gA REQUIRED_PACKAGES

	REQUIRED_PACKAGES=("${(@f)$(
		cat $SCRIPT_DIR/packages |

		sed -E \
			-e 's/#.*//' \
			-e 's/^\s+//' \
			-e 's/\s+$//' \
			-e 's/\s+/ /' \
			-e 's/\[\s+/\[/' \
			-e 's/\s+\]/\]/' |

		grep -v '^$'|

		awk '
			function print_group(){
				if (packages != ""){
					print group
					print(substr(packages,2))
				}
			}

			/^\[[^]]+\]$/{
				if (group != ""){
					print_group()
				}

				sub(/\[/,"",$0)
				sub(/\]/,"",$0)

				group = $0
				packages=""
				next
			}

			{packages = packages " " $0}

			END{
				print_group()
			}
		'
	)}")
}

package_version(){
	awk '
		/^[0-9]+\.[0-9]+.*/{
			split($1,parts,"\.")
			# printf("%-25s %-20s A:%d.%d\n",$1, $2, parts[1], parts[2])
			printf("%d.%d\n", parts[1], parts[2])
			next
		}

		/^[0-9]+[.:][0-9]+\.[0-9]+.*/{
			split($1,parts,"[.:]")
			# printf("%-25s %-20s B:%d.%d\n",$1, $2, parts[1] * 100 + parts[2], parts[3])
			printf("%d.%d\n", parts[1] * 100 + parts[2], parts[3])
			next
		}

		/^[0-9]+[.:][0-9]+.*/{
			split($1,parts,"[.:]")
			# printf("%-25s %-20s C:%d.%d\n",$1, $2, parts[1], parts[2])
			printf("%d.%d\n", parts[1], parts[2])
			next
		}

		/^[0-9]+-[0-9]+.*/{
			split($1,parts,"-")
			# printf("%-25s %-20s D:%d.%d\n",$1, $2, parts[1], parts[2])
			printf("%d.%d\n", parts[1], parts[2])
			next
		}

		/^[0-9]+*/{
			# printf("%-25s %-20s E:%d.%d\n",$1, $2, $2, 0)
			printf("%d.0\n", $2)
			next
		}

		{
			print "0.0"
			next
		}

	'
}

install_packages(){
	PACKAGE_INSTALATION=1
	INSTALLED_PACKAGES=()

	load_package_list

	install_deb_package ${(s: :)REQUIRED_PACKAGES[debian]}

	install_python_pkg  ${(s: :)REQUIRED_PACKAGES[python]}
	install_lua_pkg     ${(s: :)REQUIRED_PACKAGES[lua]}
	install_node_pkg    ${(s: :)REQUIRED_PACKAGES[node]}
	install_rust_pkg    ${(s: :)REQUIRED_PACKAGES[rust]}
	install_ruby_pkg    ${(s: :)REQUIRED_PACKAGES[ruby]}
	install_perl_pkg    ${(s: :)REQUIRED_PACKAGES[perl]}
}

#############################################
# package installation functions
#
count_installed_packages(){
	# INSTALLED_PACKAGES=$((INSTALLED_PACKAGES + 1))
	INSTALLED_PACKAGES+=("$1;$2;$3")
}

install_deb_package(){
	[[ -z $1 ]] && return

	if [[ $# -gt 1 ]] then
		for pkg in $@; do
			install_deb_package $pkg
		done

		return
	fi

	case $1 in
		node)     install_node; return;;
		rust)     install_rust; return;;
	esac

	local package=${1%/*}
	local pkg_version=${${${(M)1:#*/*}##*/}:-0.0}

	update_system

	local inst_version=$(dpkg -l $package 2>/dev/null | grep '^i' | awk '{print $3}')
	local repo_version=$(apt show $package 2>/dev/null | grep '^Version:' | sed -e 's/Version: //')

	[[ $inst_version = $repo_version ]] && return 1

	repo_version=$(echo $repo_version | package_version)
	pkg_version=${(j:.:)${(@s:.:)pkg_version}[1,2]}

	if [[ $repo_version -lt $pkg_version ]]; then
		FAILED_PACKAGES+=("$package/$repo_version/$pkg_version")
		return
	fi

	show_alert "Installing (apt)" "${package}"

	echo
	sudo apt-get install --yes $package

	count_installed_packages debian install $package
	return 0
}

install_node(){
	# retrieve version of lastest nodejs debian package
	# on github
	#
	local latest=$(
		curl -fsSL https://deb.nodesource.com/setup_current.x |
		grep 'NODEREPO="' |
		sed -e 's/NODEREPO="//' -e 's/"//g' 
	)

	local repo=$(
		apt-cache policy |
		grep -E 'https://deb\.nodesource\.com/node_.+\.x' |
		sed -E -e 's;.+ https://deb.nodesource.com/;;' -e 's;(node_.+.x) .*;\1;'
	)

	if [[ $repo != $latest ]]; then
		show_alert "Registering repo for latest" "nodejs"
		curl -fsSL https://deb.nodesource.com/setup_current.x | sudo -E bash -
	fi

	install_deb_package nodejs

	export npm_config_prefix=$__NODE_HOME

	local repo_version=$(npm view ${package} version 2>/dev/null)
	local local_version=$(npm list -g --depth 0 2>/dev/null | grep " ${package}@" | sed -e "s/.* ${package}@//" 2>/dev/null)

	[[ -z $local_version ]] && local_version=$(npm -v 2>/dev/null)

	[[ $local_version != $repo_version ]] &&  install_node_pkg npm
}

install_rust(){
	export CARGO_HOME=$__CARGO_HOME
	install_deb_package cargo
}

setup_python_venv(){
	local venv_path=$__PYTHON_HOME
	local venv_cfg=$__PYTHON_HOME/pyvenv.cfg
	local venv_lib=$__PYTHON_HOME/lib/python3

	[[ -d $venv_path   ]] || python3 -m venv --system-site-packages $venv_path

	local version=$(
		grep -E '^version\s*=\s*' $venv_cfg |
		sed -E -e 's/^version\s*=\s*//' |
		awk -F. '{print $1 "." $2}'
	)

	[[ -L $venv_lib ]] || ln -s python${version} $venv_lib
	[[ -z $VIRTUAL_ENV ]] && source $venv_path/bin/activate
}

install_python_pkg(){
	local packages=("$@")

	[[ -z $1 ]] && return

	setup_python_venv

	for package in $packages; do
		local has_pkg=$(pip3 list | grep "^$package ")

		if [[ -z $has_pkg ]]; then
			show_alert "Installing (python)" "$package"

			pip3 install $package
			echo

			count_installed_packages python install $package
		else
			local needs_update=$(pip3 list --outdated | grep "^$package ")

			if [[ -n  $needs_update ]]; then
				show_alert "Upgrading (python)" "$package"

				pip3 install --upgrade $package
				echo

				count_installed_packages python upgrade $package

			fi
		fi
	done
}

install_lua_pkg(){
	local packages=("$@")
	local package=$1

	[[ -z $1 ]] && return

	if [[ $# -ne 1 ]]; then
		for package in $packages; do
			install_lua_pkg $package
		done

		return
	fi

	local local_version=$(
		luarocks --tree $__LUA_HOME list $package |
		awk -v pkg="${(L)package}" '
			/^$/{found = 0}
			found && /\(installed\)/{print $1}
			tolower($0) == pkg { found = 1}
		' |
		sort -V |
		tail -1
	)

	local repo_version=$(
		luarocks search $package |
		awk -v pkg="${(L)package}" '
			/^$/{found = 0}
			found && /\(src\)/{print $1}
			tolower($0) == pkg { found = 1}
		' |
		sort -V |
		tail -1
	)

	[[ $local_version = $repo_version ]] && return

	if [[ -z $local_version ]]; then
		show_alert "Installing (luarocks)" "$package"
		count_installed_packages lua install $package
	else
		show_alert "Upgrading (luarocks)" "$package"
		count_installed_packages lua upgrade $package
	fi

	echo
	local errors=$(
		luarocks --tree ${__LUA_HOME} install $package 3>&1 1>&2 2>&3
	)
	echo

	if [[ -n $errors ]]; then
		echo "${y}Errors:${n}"
		echo $errors | sed -e "s/^/${s}   /"
		echo ${n}
	fi
}

install_perl_pkg(){
	local packages=("$@")
	local package=$1

	[[ -z $1 ]] && return

	if [[ $# -ne 1 ]]; then
		for package in $packages; do
			install_perl_pkg $package
		done

		return
	fi

	local has_perl5=$([[ -d ~/perl5 ]] && echo "YES")
	local has_pkg=$(perl -I $__PERL_LIB -e "use $package" 2>&1)

	if [[ -n $has_pkg ]]; then
		show_alert "Installing (perl)" "$package"

		echo
		cpanm --local-lib=$__PERL_HOME -n $package
		echo

		count_installed_packages perl install $package
	else
		local tar_pkg=${package//::/-}
		local local_version=$(perl -I $__PERL_LIB -M${package} -e 'print $'${package}'::VERSION . "\n";')
		local repo_version=$(cpanm --info $package | grep "/${tar_pkg}.*tar.gz" | sed -e "s:.*/${tar_pkg}-::" -e 's:\.tar\.gz$::')

		if [[ $local_version != $repo_version ]]; then
			show_alert "Upgrading (perl)" "$package"

			echo
			cpanm --local-lib=$__PERL_HOME -n $package
			echo

			count_installed_packages perl upgrade $package
		fi
	fi

	# if "perl5" directory has been created
	# delete it
	#
	[[ -z $has_perl5 ]] && [[ -d ~/perl5 ]] && rm -rf ~/perl5
}

install_ruby_pkg(){
	local packages=("$@")

	[[ -z $1 ]] && return

	for package in $packages; do
		local has_pkg=$(gem info $package | grep "^$package ")

		if [[ -z $has_pkg ]]; then
			show_alert "Installing (ruby)" "$package"

			echo
			sudo gem install $package
			echo

			count_installed_packages ruby install $package
		else
			local local_version=$(echo $has_pkg | sed -e "s/^${package} (//" -e 's/)//')
			local repo_version=$(gem info $package --remote | grep "^$package " | sed -e "s/^${package} (//" -e 's/)//')

			if [[ $local_version != $repo_version ]]; then
				show_alert "Upgrading (ruby)" "$package"

				echo
				sudo gem install $package
				echo

				count_installed_packages ruby update $package
			fi
		fi
	done
}


install_node_pkg(){
	local packages=("$@")
	local package=$1

	[[ -z $1 ]] && return

	if [[ $# -ne 1 ]]; then
		for package in $packages; do
			install_node_pkg $package
		done
	fi

	export npm_config_prefix=$__NODE_HOME

	local local_version=$(npm list -g --depth 0 2>/dev/null | grep " ${package}@" | sed -e "s/.* ${package}@//")

	if [[ -z $local_version ]]; then
		show_alert "Installing (npm)" "$package"

		npm install -g $package
		echo

		count_installed_packages node install $package
	else
		local repo_version=$(npm view ${package} version)

		if [[ $local_version != $repo_version ]]; then
			show_alert "Upgrading (npm)" "$package"

			npm install -g $package
			echo

			count_installed_packages node upgrade $package
		fi
	fi

	unset npm_config_prefix
}

install_rust_pkg(){
	local packages=("$@")

	[[ -z $1 ]] && return

	for package in $packages; do
		local has_pkg=$(cargo install --list | grep "^${package##*::} ")

		if [[ -z $has_pkg ]]; then
			show_alert "Installing (cargo)" "${package##*::}"

			echo
			cargo install ${package##*::}
			echo

			count_installed_packages rust install $package
		else
			local local_version=$(echo $has_pkg | awk '{print $NF}' | sed -e 's/:$//' -e 's/^v//')
			local repo_version=$(cargo search -q ${package##*::} | grep "^${package##*::} " | sed -e 's/^.*= "//' -e 's/".*//')

			if [[ $local_version != $repo_version ]]; then
				show_alert "Upgrading (cargo)" "${package##*::}"

				echo
				cargo install ${package##*::}
				echo

				count_installed_packages rust upgrade $package
			fi
	 fi
	done

	# warning: be sure to add `/home/koske/.local/share/nvim/cargo/bin` to your PATH to be able to run the installed binaries
}

#############################################
# worker functions
#
show_alert(){
	local action=$1
	local object=$2
	local alert_width=80
	local void

	#  echo 
	#  echo "${g}###############################################"
	#  echo "${g}# ${w}${action}:${y} ${object}${n}"
	#  echo "${g}###############################################"
	#  echo ${n}
	
	[[ -n $object ]] && action="${action}:"
	
	echo 
	echo "${g}${(l:$alert_width::#:)void}"
	echo "${g}# ${w}${action}${y} ${object}${n}"
	echo "${g}${(l:$alert_width::#:)void}${n}"
	# echo ${n}

}

download_appimage(){
	local url="$NEOVIM_DOWNLOAD_URL/nvim.appimage"
	local dest=/usr/local/bin
	local mode='oug+rx'

	install_deb_package libfuse2
	install_deb_package curl

	local prog=$dest/nvim.appimage

	[[ ! -d $dest ]] && mkdir $dest && chmod 755 $dest
	[[ -f $dest/$app ]] && sudo rm $dest/$app

	show_alert "Downloading" "neovim appImage"
	sudo curl -fL -o $prog $url
	echo

	show_alert "Installing" "neovim appImage"
	sudo chmod $mode $prog
}

download_deb_pkg(){
	local url="$NEOVIM_DOWNLOAD_URL/nvim-linux64.deb"
	local dest=/tmp

	install_deb_package curl

	local pkg=$dest/nvim-linux64.deb

	show_alert "Downloading" "neovim deb package"
	echo
	sudo curl -fL -o $pkg $url
	echo

	local inst_version=$(dpkg -l neovim 2>/dev/null | grep '^i' | awk '{print $3}')
	local repo_version=$(apt show $pkg 2>/dev/null | grep '^Version:' | sed -e 's/Version: //')

	
	if [[ $inst_version = $repo_version ]]; then
		alert_box --expand "Newest version of ${r}neovim${y} already installed!"
		return
	fi

	show_alert "Installing" "neovim deb package"

	echo
	sudo apt install $pkg

	count_installed_packages debian install neovim
}

register_neovim_app(){
	local app=$1
	local link=$2
	local action=$3
	local explicite

	local APP_PATH=$(which $app)

	local registered=$(sudo update-alternatives --list ${link} | grep "^${APP_PATH}$")

	[[ -n $registered ]] && return

	show_alert "Registering \"$app\" as ${y}${link}${w}"

	echo
	echo
	echo -n "[1A"
	echo -n "Do you want to register \"neovim\" as ${y}${link}${n} "

	if [[ $action = Y ]]; then
		echo -n "[Y/n]: "
		explicite="n"
	else
		echo -n "[y/N]: "
		explicite="y"
	fi

	read yesno

	[[ ${(L)yesno}  = $explicite ]] && [[ $action = Y ]] && return
	[[ ${(L)yesno} != $explicite ]] && [[ $action = N ]] && return


	set -u

	echo
	sudo update-alternatives --install /usr/bin/${link} ${link} "${APP_PATH}" 110
	sudo update-alternatives --set ${link} "${APP_PATH}"
}


update_system(){
	[[ $UPGRADED -eq 1 ]] && return

	echo
	sudo -v

	show_alert "Updating" "system package list"

	sudo apt-get -q update >/dev/null

	local test_run=$(apt-get -s upgrade)

	local upgradable=($(
		echo $test_run |
		awk '
			/^[^ \t]+/ {flag = 0}
			flag {print}
			/The following packages will be upgraded:/ {flag = 1}
		'
	))

	local keptback=($(
		echo $test_run |
		awk '
			/^[^ \t]+/ {flag = 0}
			flag {print}
			/The following packages have been kept back:/ {flag = 1}
		'
	))

	AUTO_REMOVE_PKGS=($(
		echo $test_run |
		awk '
			/^[^ \t]+/ {flag = 0}
			flag {print}
			/automatically installed and .* longer required:/ {flag = 1}
		'
	))


	CLEARED=0

	if [[ -n $upgradable ]]; then
		[[ $CLEARED -eq 0 ]] && clear
	       	CLEARED=1

		echo
		show_alert "ALERT" "Your system needs upgrade !!!"
		echo 

		if yesno_question "Do you want to upgrades the system [y/N]:" N; then
			sudo apt-get upgrade -qq --yes
			echo
		else
			exit
		fi

	fi

	if [[ -n $keptback ]]; then
		[[ $CLEARED -eq 0 ]] && clear
	       	CLEARED=1

		{
			echo "Following packages are kept back:"
			echo
			echo ${(j:\n:)${(@)keptback/#/   ${n}}}${y}
			echo
			echo "They have to be installed manualy!"
		} | sed -e 's/^/   /' | alert_box --expand --left

		if yesno_question "Do you want to install kept back packages [y/N]:" N; then
			sudo apt-get install -qq --yes $keptback
			echo
		else
			exit
		fi
	fi

	UPGRADED=1
}

yesno_question(){
	local prompt=$1
	local default=${(L)2}

	local yesno

	echo -n "${prompt} "
	read yesno
	echo

	[[ $default = n ]] && [[ ${(L)yesno} != y ]] && return 1
	[[ $default = y ]] && [[ ${(L)yesno} != n ]] && return 0

	[[ ${(L)yesno} = y ]] && return 0
	[[ ${(L)yesno} = n ]] && return 1

	return 1
}

##############################################################################
# Show some notifications on end of install
#
show_notifications(){
	local void
	local txt

	[[ $PACKAGE_INSTALATION -eq 0 ]] && return

	if [[ -z $INSTALLED_PACKAGES ]] && [[ -z $FAILED_PACKAGES ]]; then
		alert_box --expand "No packagages were installed !!!"
	fi

	if [[ -n $INSTALLED_PACKAGES ]]; then
		{
			echo "Following packages were installed:"
			echo
			printf "${n}%-10s %-10s %-25s\n" "Type" "Action" "Package"
			echo ${(l:48::-:)txt}

			for package in $INSTALLED_PACKAGES; do
				local parts=("${(s:;:)package}")
				printf "${n}%-10s %-10s %-25s\n" $parts[1] $parts[2] $parts[3]
			done

		} | sed -e 's/^/   /' | alert_box --left --expand
	fi

	if [[ -n $FAILED_PACKAGES ]]; then
		cat <<-EOF | alert_box --expand
			Some packages were not installed
			since version of package available on
			repository is less than minimaly requested.

			${r}Install named packages manually${n}
		EOF

		echo ${g}

		txt=""     && echo -n "${(r:35:)txt}"
		txt="repo" && echo -n "${(r:10:)txt}"
		txt="min"  && echo -n "${txt}"
		echo
		txt="package" && echo -n "${(r:35:)txt}"
		txt="version" && echo -n "${(r:10:)txt}"
		txt="version" && echo -n "${txt}"
		echo

		echo "${(l:80::-:)void}"
		echo -n "$n"

		for pkg in $FAILED_PACKAGES; do
			local parts=("${(s:/:)pkg}")

			echo -n "${y}${(r:35:)parts[1]}${n}"
			echo -n "${r}${(r:10:)parts[2]}${n}"
			echo -n "${b}(${parts[3]})${n}"
			echo
		done

		echo
	fi

	if [[ -n $AUTO_REMOVE_PKGS ]]; then
		{
			echo "Following packages can be removed, since they are not needed:"
			echo
			echo ${(j:\n:)${(@)AUTO_REMOVE_PKGS/#/   ${n}}}
			echo
			echo "To remove them run:"
			echo "   ${n}apt autoremove${y}"
		} | sed -e 's/^/   /' | alert_box --expand --left
	fi
}

alert_box(){
	local width=80
	local void
	local align=C
	local expand=0
	local border="#"

	############################################################
	# parse command options 
	#   --left       - text aligment
	#   --right      -    -||-
	#   --center     -    -||-
	#
	#   --expand     - add empty line before, and after text
	#
	local ARGS BORDER WIDTH

	zparseopts -E -D -A ARGS \
		-left \
		-right \
		-center \
		-expand \
		-width:=WIDTH \
		-border:=BORDER

	[[ ${+ARGS[--left]}   -eq 1 ]] && align=L
	[[ ${+ARGS[--right]}  -eq 1 ]] && align=R
	[[ ${+ARGS[--center]} -eq 1 ]] && align=C
	[[ ${+ARGS[--expand]} -eq 1 ]] && expand=1

	[[ -n $BORDER ]] && border=${${BORDER[2]}[1]}
	[[ -n $WIDTH  ]] && width=${WIDTH[2]}

	local lines=("$@")
	local bline=${${(l:$width::.:)void}//./${border}}

	[[ -z $lines ]] && lines=("${(@f)$(cat)}")

	echo 
	echo "${g}${bline}${n}"

	[[ $expand -eq 1 ]] && echo "${g}${border}${(l:$((width - 2)):: :)void}${border}${n}"

	local text
	local len
	local left
	local right

	for line in "${(@)lines}"; do
		text=$line

		# strip ansi sequence
		#
		strip_ansi_escape text

		len=$#text

		case $align in 
			C)
				left=$(((width - 2 - len) / 2))
				right=$((width - 2 - len - left))
				;;
			L)
				left=0
				right=$((width - 2 - len ))
				;;
			R)
				right=0
				left=$((width - 2 - len ))
				;;
		esac

		echo -n "${g}${border}${(l:$left:: :)void}${n}"
		echo -n "${y}${line}${n}"
		echo -n "${g}${(l:$right:: :)void}${border}${n}"
		echo

	done

	[[ $expand -eq 1 ]] && echo "${g}${border}${(l:$((width - 2)):: :)void}${border}${n}"

	echo "${g}${bline}${n}"
	echo
}

strip_ansi_escape(){
	if [[ -o RE_MATCH_PCRE ]]; then
		eval "regexp-replace $1 '(\x9B|\x1B\[)[0-9:;<>=?]*[ -\/]*[@-~]' ''"
	else
		setopt RE_MATCH_PCRE
		eval "regexp-replace $1 '(\x9B|\x1B\[)[0-9:;<>=?]*[ -\/]*[@-~]' ''"
		unsetopt RE_MATCH_PCRE
	fi
}

parse_arguments(){
	local commands=(all neovim packages)
	local cmd=(${(M)commands:#${1}*}) 

	[[ $#cmd -eq 0 ]] && SCRIPT_COMMAND="exec_help"                         
	[[ $#cmd -eq 1 ]] && SCRIPT_COMMAND="exec_$cmd"                         
	[[ $#cmd -gt 1 ]] && SCRIPT_COMMAND="exec_help"

	shift 2>/dev/null

	SCRIPT_ARGS=("$@")
}

init_colors
check_if_root
parse_arguments $@

$SCRIPT_COMMAND "${SCRIPT_ARGS[@]}"

show_notifications
