#!/usr/bin/zsh

autoload -U regexp-replace

SCRIPT_DIR=${0:a:h}

source $SCRIPT_DIR/src/zfm
source $SCRIPT_DIR/src/common


#############################################
# init functions
#
init_colors(){
	r='[31m'
	g='[32m'
	y='[33m'
	b='[34m'
	m='[35m'
	c='[36m'
	w='[37m'
	n='[0m'

	if [[ $(tput colors) -lt 256 ]]; then
		s='[90m'
	else
		s='[38;5;243m'
	fi

	zterm init
	zmenu init
}


#############################################
# main functions
#
exec_help(){
	init_colors

	cat <<-EOF

		   ${w}usage:${n}
		      install COMMAND

		   ${w}commands:${n}
		      neovim     - install latest neovim
		      packages   - install other programs/modules (nodejs, ruby,
		                   perl, pynvim, ruby nvim, rust, ...)

		      all        - run all the above in single run

	EOF
}

exec_all(){
	install_packages
	# install_neovim
}

exec_neovim(){
	# install_neovim $@
}

exec_packages(){
	install_packages
}

install_packages(){
	load_package_list
	# what_to_install

	local -A NEED_PKG

	# NEED_PKG[node]=1
	# NEED_PKG[lua]=1
	NEED_PKG[python]=1
	# NEED_PKG[system]=1

	install_pkg system ${(s: :)REQUIRED_PACKAGES[system]}

	install_pkg node   ${(s: :)REQUIRED_PACKAGES[node]}
	install_pkg python ${(s: :)REQUIRED_PACKAGES[python]}
	install_pkg lua    ${(s: :)REQUIRED_PACKAGES[lua]}
	install_pkg rust   ${(s: :)REQUIRED_PACKAGES[rust]}
	install_pkg ruby   ${(s: :)REQUIRED_PACKAGES[ruby]}
	install_pkg perl   ${(s: :)REQUIRED_PACKAGES[perl]}
}

what_to_install(){

	local selection=()
	local menu_prompt=""

	menu_prompt+="[${g}ENTER: ${n}select] "
	menu_prompt+="[${g}CTRL+A: ${n}all] "
	menu_prompt+="[${g}CTRL+N: ${n}none]   "
	menu_prompt+="[${y}CTRL+X: ${n}end] "
	menu_prompt+="[${y}CTRL+C: ${n}quit]"

	# clear; echo

	local pkgs=(
		"python"
		"node"
		"rust"
		"lua"
		"ruby"
		"perl"
	)

	zmenu select selection\
		--width 60 \
		--selected-color "c" \
		--selected "4" \
		--multy \
		--focus 1 \
		--color 'g b' \
		--align "r l l c r l" \
		--spaces "1 2 ' [' '] ' ' [' 1 '] ' 2" \
		--no-bottom-line \
		--title "${b}Install following groups of packages:"\
		--prompt "$menu_prompt" \
		$pkgs

	echo "Selection:" $selection

	typeset -gA NEED_PKG

	local pkg

	for  pkg in $pkgs; do
		NEED_PKG[$pkg]=0
	done

	for  pkg in $selection; do
		NEED_PKG[$pkgs[$pkg]]=1
	done

	NEED_PKG[system]=1
}

#############################################
# package installation functions
#
install_pkg(){
	local type=$1; shift

	[[ $NEED_PKG[$type] -eq 0 ]] && return

	for pkg in $@; do
		install_${type}_pkg $pkg
	done
}

install_system_pkg (){
	local todo
	local package=$1

	update_system
	sys_package action todo $package

	if [[ $todo = keep ]] then
		count_success $OS kept $package
		return 0
	elif [[ $todo = missing ]] then
		count_fails $package missing
		return 1
	elif [[ ${todo%%:*} = old ]] then
		local parts=${(s.:.)todo}
		count_fails $package "$parts[2]" "$parts[3]"
		return 1
	fi

	package=${todo#*:}

	show_alert "Installing [$OS]" "${package}"

	echo
	sys_package install $package

	if [[ $? -eq 0 ]]; then
		count_success $OS installed $package
		return 0
	else
		count_fails $OS "failed to install" $package
		return 1
	fi
}

install_python_pkg(){
	local package=$1

	install_python

	[[ $PYTHON_BIN -eq 0 ]] && count_fails $package "python3 not installed"

	show_alert "Checking [python]" "$package"

	local has_pkg=$(pip3 list 2>/dev/null | grep "^$package ")

	if [[ -z $has_pkg ]]; then
		clear_screen 4

		show_alert "Installing [python]" "$package"

		pip3 install $package
		echo

		count_success python install $package

	else
		local needs_update=$(pip3 list --outdated 2>/dev/null | grep "^$package ")

		clear_screen 4

		if [[ -n  $needs_update ]]; then
			show_alert "Upgrading [python]" "$package"

			pip3 install --upgrade $package
			echo

			count_success python upgrade $package

		fi
	fi
}

install_lua_pkg(){
	local package=$1

	install_luarocks

	show_alert "Checking [lua]" "$package"

	local local_version=$(
		luarocks --tree $__LUA_HOME list $package |
		awk -v pkg="${(L)package}" '
			/^$/{found = 0}
			found && /\(installed\)/{print $1}
			tolower($0) == pkg { found = 1}
		' |
		sort -V |
		tail -1
	)

	local repo_version=$(
		luarocks search $package |
		awk -v pkg="${(L)package}" '
			/^$/{found = 0}
			found && /\(src\)/{print $1}
			tolower($0) == pkg { found = 1}
		' |
		sort -V |
		tail -1
	)

	# clear_screen 4

	[[ $local_version = $repo_version ]] && return

	if [[ -z $local_version ]]; then
		show_alert "Installing [luarocks]" "$package"
		count_success lua install $package
	else
		show_alert "Upgrading [luarocks]" "$package"
		count_success lua upgrade $package
	fi

	echo
	local errors=$(
		luarocks --tree ${__LUA_HOME} install $package 3>&1 1>&2 2>&3
	)
	echo

	if [[ -n $errors ]]; then
		echo "${y}Errors:${n}"
		echo $errors | sed -e "s/^/${s}   /"
		echo ${n}
	fi
}

install_perl_pkg(){
	local package=$1

	install_perl

	show_alert "Checking [perl]" "$package"

	local has_perl5=$([[ -d ~/perl5 ]] && echo "YES")
	local has_pkg=$(perl -I $__PERL_LIB -e "use $package" 2>&1)

	if [[ -n $has_pkg ]]; then
		clear_screen 4

		show_alert "Installing [perl]" "$package"

		echo
		cpanm --local-lib=$__PERL_HOME -n $package
		echo

		count_success perl install $package
	else
		local tar_pkg=${package//::/-}
		local local_version=$(perl -I $__PERL_LIB -M${package} -e 'print $'${package}'::VERSION . "\n";')
		local repo_version=$(cpanm --info $package | grep "/${tar_pkg}.*tar.gz" | sed -e "s:.*/${tar_pkg}-::" -e 's:\.tar\.gz$::')

		clear_screen 4

		if [[ $local_version != $repo_version ]]; then
			show_alert "Upgrading [perl]" "$package"

			echo
			cpanm --local-lib=$__PERL_HOME -n $package
			echo

			count_success perl upgrade $package
		fi
	fi

	# if "perl5" directory has been created
	# delete it
	#
	[[ -z $has_perl5 ]] && [[ -d ~/perl5 ]] && rm -rf ~/perl5
}

install_ruby_pkg(){
	local package=$1

	install_ruby

	show_alert "Checking [ruby]" "$package"

	local has_pkg=$(gem info $package | grep "^$package ")

	[[ -d $__RUBY_BIN ]] || mkdir -p $__RUBY_BIN

	if [[ -z $has_pkg ]]; then
		clear_screen 4

		show_alert "Installing [ruby]" "$package"

		echo
		gem install --user-install -n $__RUBY_BIN $package
		echo

		count_success ruby install $package
	else
		local local_version=$(echo $has_pkg | sed -e "s/^${package} (//" -e 's/)//')
		local repo_version=$(gem info $package --remote | grep "^$package " | sed -e "s/^${package} (//" -e 's/)//')

		clear_screen 4

		if [[ $local_version != $repo_version ]]; then
			show_alert "Upgrading [ruby]" "$package"

			echo
			gem install --user-install -n $__RUBY_BIN $package
			# sudo gem install $package
			echo

			count_success ruby update $package
		fi
	fi
}


install_node_pkg(){
	local package=$1

	install_node

	show_alert "Checking [npm]" "$package"

	export npm_config_prefix=$__NODE_HOME

	local local_version=$(npm list -g --depth 0 2>/dev/null | grep " ${package}@" | sed -e "s/.* ${package}@//")

	if [[ -z $local_version ]]; then
		clear_screen 4

		show_alert "Installing [npm]" "$package"

		npm install -g $package
		echo

		count_success node install $package
	else
		local repo_version=$(npm view ${package} version)

		clear_screen 4

		if [[ $local_version != $repo_version ]]; then
			show_alert "Upgrading [npm]" "$package"

			npm install -g $package
			echo

			count_success node upgrade $package
		fi
	fi

	unset npm_config_prefix
}

install_rust_pkg(){
	local package=$1

	install_rust

	show_alert "Checking [rust]" "$package"

	local has_pkg=$(cargo install --list | grep "^${package##*::} ")

	if [[ -z $has_pkg ]]; then
		clear_screen 4

		show_alert "Installing [cargo]" "${package##*::}"

		echo
		cargo install ${package##*::}
		echo

		count_success rust install $package
	else
		local local_version=$(echo $has_pkg | awk '{print $NF}' | sed -e 's/:$//' -e 's/^v//')
		local repo_version=$(cargo search -q ${package##*::} | grep "^${package##*::} " | sed -e 's/^.*= "//' -e 's/".*//')

		clear_screen 4

		if [[ $local_version != $repo_version ]]; then
			show_alert "Upgrading [cargo]" "${package##*::}"

			echo
			cargo install ${package##*::}
			echo

			count_success rust upgrade $package
		fi
 fi

	# warning: be sure to add `/home/koske/.local/share/nvim/cargo/bin` to your PATH to be able to run the installed binaries
}

install_neovim_package(){
	local app
	local pkg=$1

	case $pkg in 
		app) app=nvim.appimage
			 ;;
		deb) app=nvim
			 ;;
	esac

	if [[ -z $app ]]; then

		cat <<-EOF | alert_box --left
			${y}
			  Give package type you want to install:
			
			    ${w}app${y}   - install appImage
			    ${w}deb${y}   - install debian package
			${n}
		EOF

		exit 1
	fi

	local is_installed=$(hash $app 2>/dev/null; echo $?)

	case $pkg in
		app) download_appimage
			 register_neovim_app nvim.appimage vi  N
			 register_neovim_app nvim.appimage vim Y
			 ;;
		deb) download_deb_pkg
			 register_neovim_app nvim vi  N
			 register_neovim_app nvim vim Y
			 ;;
	esac

	echo
}

install_node(){
	install_node_package

	install_node_pkg npm

	# export npm_config_prefix=$__NODE_HOME
	#
	# local repo_version=$(npm view ${package} version 2>/dev/null)
	# local local_version=$(npm list -g --depth 0 2>/dev/null | grep " ${package}@" | sed -e "s/.* ${package}@//" 2>/dev/null)
	#
	# [[ -z $local_version ]] && local_version=$(npm -v 2>/dev/null)
	#
	# [[ $local_version != $repo_version ]] &&  install_node_pkg npm
}

install_rust(){
	export CARGO_HOME=$__CARGO_HOME
	install_system_package $1
}

#############################################
# worker functions
#
clear_screen(){
	for i in {1..$1}; do
		echo -n '[A[2K'
	done
}

show_alert(){
	local action=$1
	local object=$2
	local alert_width=80
	local void

	#  echo 
	#  echo "${g}###############################################"
	#  echo "${g}# ${w}${action}:${y} ${object}${n}"
	#  echo "${g}###############################################"
	#  echo ${n}
	
	[[ -n $object ]] && action="${action}:"
	
	echo 
	echo "${g}${(l:$alert_width::#:)void}"
	echo "${g}# ${w}${action}${y} ${object}${n}"
	echo "${g}${(l:$alert_width::#:)void}${n}"
	# echo ${n}

}

download_appimage(){
	local app=nvim.appimage
	local url="$NEOVIM_DOWNLOAD_URL/$app"
	# local dest=/usr/local/bin
	local dest=/opt/nvim
	local mode='oug+rx'

	install_deb_package libfuse2
	install_deb_package curl

	local prog=$dest/nvim.appimage

	[[ -d $dest ]] || sudo mkdir $dest && sudo chmod 755 $dest
	[[ -f $prog ]] && sudo rm $prog

	show_alert "Downloading" "neovim appImage"
	sudo curl -fL -o $prog $url
	echo

	show_alert "Installing" "neovim appImage"
	sudo chmod $mode $prog
	sudo ln -s $prog /usr/local/bin/nvim 
}

download_deb_pkg(){
	local url="$NEOVIM_DOWNLOAD_URL/nvim-linux64.deb"
	local dest=/tmp

	install_system_package curl

	local pkg=$dest/nvim-linux64.deb

	show_alert "Downloading" "neovim deb package"
	echo
	sudo curl -fL -o $pkg $url
	echo

	local inst_version=$(dpkg -l neovim 2>/dev/null | grep '^i' | awk '{print $3}')
	local repo_version=$(apt show $pkg 2>/dev/null | grep '^Version:' | sed -e 's/Version: //')

	
	if [[ $inst_version = $repo_version ]]; then
		alert_box --expand "Newest version of ${r}neovim${y} already installed!"
		return
	fi

	show_alert "Installing" "neovim deb package"

	echo
	sudo apt install $pkg

	count_success debian install neovim
}

register_neovim_app(){
	local app=$1
	local link=$2
	local action=$3
	local explicite

	local APP_PATH=$(which $app)

	local registered=$(sudo update-alternatives --list ${link} | grep "^${APP_PATH}$")

	[[ -n $registered ]] && return

	show_alert "Registering \"$app\" as ${y}${link}${w}"

	echo
	echo
	echo -n "[1A"
	echo -n "Do you want to register \"neovim\" as ${y}${link}${n} "

	if [[ $action = Y ]]; then
		echo -n "[Y/n]: "
		explicite="n"
	else
		echo -n "[y/N]: "
		explicite="y"
	fi

	read yesno

	[[ ${(L)yesno}  = $explicite ]] && [[ $action = Y ]] && return
	[[ ${(L)yesno} != $explicite ]] && [[ $action = N ]] && return


	set -u

	echo
	sudo update-alternatives --install /usr/bin/${link} ${link} "${APP_PATH}" 110
	sudo update-alternatives --set ${link} "${APP_PATH}"
}


yesno_question(){
	local prompt=$1
	local default=${(L)2}

	local yesno

	echo
	while true; do
		echo -n '[1A[2K'
		echo -n "${prompt} "
		read yesno

		if [[ -z $yesno ]] || [[ ${(L)yesno} = y ]] || [[ ${(L)yesno} = n ]] then
			echo 
			break
		fi
	done

	[[ $default = n ]] && [[ ${(L)yesno} != y ]] && return 1
	[[ $default = y ]] && [[ ${(L)yesno} != n ]] && return 0

	[[ ${(L)yesno} = y ]] && return 0
	[[ ${(L)yesno} = n ]] && return 1

	return 1
}

##############################################################################
# Show some notifications on end of install
#
show_notifications(){
	local void
	local txt

	if [[ -z $INSTALLED_PACKAGES ]] && [[ -z $FAILED_PACKAGES ]]; then
		alert_box --expand "No packagages were installed !!!"
	fi

	if [[ -n $INSTALLED_PACKAGES ]]; then
		{
			echo "Following packages were installed/upgraded/kept:"
			echo
			printf "${n}%-10s %-10s %-25s\n" "Type" "Action" "Package"
			echo ${(l:48::-:)txt}

			for package in $INSTALLED_PACKAGES; do
				local parts=("${(s:;:)package}")
				printf "${n}%-10s %-10s %-25s\n" $parts[1] $parts[2] $parts[3]
			done

		} | sed -e 's/^/   /' | alert_box --left --expand
	fi

	if [[ -n $FAILED_PACKAGES ]]; then
		cat <<-EOF | alert_box --expand
			Some packages were not installed
			since version of package available on
			repository is less than minimaly requested.

			${r}Install named packages manually${n}
		EOF

		echo ${g}

		txt=""     && echo -n "${(r:35:)txt}"
		txt="repo" && echo -n "${(r:10:)txt}"
		txt="min"  && echo -n "${txt}"
		echo
		txt="package" && echo -n "${(r:35:)txt}"
		txt="version" && echo -n "${(r:10:)txt}"
		txt="version" && echo -n "${txt}"
		echo

		echo "${(l:80::-:)void}"
		echo -n "$n"

		for pkg in $FAILED_PACKAGES; do
			local parts=("${(s:;:)pkg}")

			echo -n "${y}${(r:35:)parts[1]}${n}"
			echo -n "${r}${(r:10:)parts[2]}${n}"
			[[ -n $parts[3] ]] && echo -n "${b}(${parts[3]})${n}"
			echo
		done

		echo
	fi

	if [[ -n $AUTO_REMOVE_PKGS ]]; then
		{
			echo "Following packages can be removed, since they are not needed:"
			echo
			echo ${(j:\n:)${(@)AUTO_REMOVE_PKGS/#/   ${n}}}
			echo
			echo "To remove them run:"
			echo "   ${n}apt autoremove${y}"
		} | sed -e 's/^/   /' | alert_box --expand --left
	fi
}

alert_box(){
	local width=80
	local void
	local align=C
	local expand=0
	local border="#"

	############################################################
	# parse command options 
	#   --left       - text aligment
	#   --right      -    -||-
	#   --center     -    -||-
	#
	#   --expand     - add empty line before, and after text
	#
	local ARGS BORDER WIDTH

	zparseopts -E -D -A ARGS \
		-left \
		-right \
		-center \
		-expand \
		-width:=WIDTH \
		-border:=BORDER

	[[ ${+ARGS[--left]}   -eq 1 ]] && align=L
	[[ ${+ARGS[--right]}  -eq 1 ]] && align=R
	[[ ${+ARGS[--center]} -eq 1 ]] && align=C
	[[ ${+ARGS[--expand]} -eq 1 ]] && expand=1

	[[ -n $BORDER ]] && border=${${BORDER[2]}[1]}
	[[ -n $WIDTH  ]] && width=${WIDTH[2]}

	local lines=("$@")
	local bline=${${(l:$width::.:)void}//./${border}}

	[[ -z $lines ]] && lines=("${(@f)$(cat)}")

	echo 
	echo "${g}${bline}${n}"

	[[ $expand -eq 1 ]] && echo "${g}${border}${(l:$((width - 2)):: :)void}${border}${n}"

	local text
	local len
	local left
	local right

	for line in "${(@)lines}"; do
		text=$line

		# strip ansi sequence
		#
		strip_ansi_escape text

		len=$#text

		case $align in 
			C)
				left=$(((width - 2 - len) / 2))
				right=$((width - 2 - len - left))
				;;
			L)
				left=0
				right=$((width - 2 - len ))
				;;
			R)
				right=0
				left=$((width - 2 - len ))
				;;
		esac

		echo -n "${g}${border}${(l:$left:: :)void}${n}"
		echo -n "${y}${line}${n}"
		echo -n "${g}${(l:$right:: :)void}${border}${n}"
		echo

	done

	[[ $expand -eq 1 ]] && echo "${g}${border}${(l:$((width - 2)):: :)void}${border}${n}"

	echo "${g}${bline}${n}"
	echo
}

strip_ansi_escape(){
	if [[ -o RE_MATCH_PCRE ]]; then
		eval "regexp-replace $1 '(\x9B|\x1B\[)[0-9:;<>=?]*[ -\/]*[@-~]' ''"
	else
		setopt RE_MATCH_PCRE
		eval "regexp-replace $1 '(\x9B|\x1B\[)[0-9:;<>=?]*[ -\/]*[@-~]' ''"
		unsetopt RE_MATCH_PCRE
	fi
}

parse_arguments(){
	local commands=(all neovim packages)
	local cmd=(${(M)commands:#${1}*}) 

	[[ $#cmd -eq 0 ]] && SCRIPT_COMMAND="exec_help"                         
	[[ $#cmd -eq 1 ]] && SCRIPT_COMMAND="exec_$cmd"                         
	[[ $#cmd -gt 1 ]] && SCRIPT_COMMAND="exec_help"

	shift 2>/dev/null

	SCRIPT_ARGS=("$@")
}

init_colors

check_if_root
check_linux_flavour

parse_arguments $@

$SCRIPT_COMMAND "${SCRIPT_ARGS[@]}"

show_notifications
