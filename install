#!/usr/bin/zsh

autoload -U regexp-replace

SCRIPT_DIR=${0:a:h}

# source $SCRIPT_DIR/src/zfm
# source $SCRIPT_DIR/src/common

source $SCRIPT_DIR/lib/core


#############################################
# init functions
#
init_colors(){
	r='[31m'
	g='[32m'
	y='[33m'
	b='[34m'
	m='[35m'
	c='[36m'
	w='[37m'
	n='[0m'

	if [[ $(tput colors) -lt 256 ]]; then
		s='[90m'
	else
		s='[38;5;243m'
	fi

	zterm init
	zmenu init
}


#############################################
# main functions
#
exec_help(){
	init_colors

	cat <<-EOF

		   ${y}usage:${n}
		      install COMMAND

		   ${y}commands:${n}
		      neovim     - install latest neovim
		      cliboard   - install cliboard interface utility
		      packages   - install other programs/modules (nodejs, ruby,
		                   perl, pynvim, ruby nvim, rust, ...)

		      all        - run all the above in single run

		   ${y}note:${n}
		      command names can be abbrevated: neo, cli, ...

	EOF

	exit
}

exec_all(){
	update_system
	install_packages
	install_neovim
	install_cliboard
}

exec_neovim(){
	update_system
	install_neovim
}

exec_packages(){
	install_packages
}

exec_cliboard(){
	update_system
	install_cliboard
}


#############################################
# package installation functions
#
install_packages(){
	zpackage system packages-select

	local module
	local MODULES=(system ${${(k)SELECTED_MODULES}:#system})
	# local MODULES=(${${(k)SELECTED_MODULES}:#system})
	# local MODULES=(ruby)


	echo MODULES: $MODULES

	for module in $MODULES; do
		zpackage $module install ${=MODULE_PACKAGES[$module]}
	done
}

install_cliboard(){
	local selection
	local menu_prompt=""


	menu_prompt+="[${g}ENTER: ${n}select] "
	menu_prompt+="[${y}CTRL+C: ${n}quit]"

	local pkgs=(
		"xclip;cliboard support on X11"
		"xsel;cliboard support on X11"
		"wl-clipboard;cliboard support on Wayland"
		"   "
		"none"
	)

	alert_msg "${y}Select cliboard support package"

	zmenu select selection\
		--width 60 \
		--header "Pkg;Description" \
		--selected-color "b" \
		--focus 1 \
		--color 'g y n' \
		--align "r l l" \
		--spaces "1 2 2" \
		--no-bottom-line \
		--prompt "$menu_prompt" \
		$pkgs

	echo

	[[ -z $selection ]] && return

	local selected=${pkgs[$selection]%%;*}

	[[ $selected = none ]] && return

	install_pkg system $selected
}


#############################################
# worker functions
#
register_neovim_app(){
	local app=$1
	local link=$2
	local action=$3
	local explicite

	local APP_PATH=$(which $app)

	local registered=$(sudo update-alternatives --list ${link} | grep "^${APP_PATH}$")

	[[ -n $registered ]] && return

	alert_msg "Registering \"$app\" as ${y}${link}${w}"

	echo
	echo
	echo -n "[1A"
	echo -n "Do you want to register \"neovim\" as ${y}${link}${n} "

	if [[ $action = Y ]]; then
		echo -n "[Y/n]: "
		explicite="n"
	else
		echo -n "[y/N]: "
		explicite="y"
	fi

	read yesno

	[[ ${(L)yesno}  = $explicite ]] && [[ $action = Y ]] && return
	[[ ${(L)yesno} != $explicite ]] && [[ $action = N ]] && return

	echo
	sudo update-alternatives --install /usr/bin/${link} ${link} "${APP_PATH}" 110
	sudo update-alternatives --set ${link} "${APP_PATH}"
}


##############################################################################
# Show some notifications on end of install
#
show_notifications(){
	local void
	local txt

	if [[ -z $INSTALLED_PACKAGES ]] && [[ -z $FAILED_PACKAGES ]]; then
		alert_box --expand "No packagages were installed !!!"
	fi

	local last_type

	if [[ -n $INSTALLED_PACKAGES ]]; then
		last_type=""

		{
			echo "Following packages were installed/upgraded/kept:"
			echo
			printf "${n}%-10s %-25s %s\n" "Type" "Package" "Action"
			echo ${(l:60::-:)txt}

			for package in ${(O)INSTALLED_PACKAGES}; do
				local parts=("${(s:;:)package}")

				if [[ -n $last_type ]] && [[ $last_type != $parts[1] ]]; then
					local len=($#last_type $#parts[1])
					local cnum=${${(On)len}[1]}
					echo "${s}${(l:$cnum::-:)txt}"
				fi

				echo -n "${y}${(r:10:)parts[1]}${n} "
				echo -n "${n}${(r:25:)parts[2]}${n} "
				echo -n "${b}${parts[3]}${n}"
				echo

				last_type=$parts[1]
			done

		} | sed -e 's/^/   /' | alert_box --left --expand
	fi

	if [[ -n $FAILED_PACKAGES ]]; then
		last_type=""

		{
			echo "We failed to install following packages:"
			echo
			printf "${n}%-10s %-25s %-25s\n" "Type" "Package" "Reason"
			echo "${(l:60::-:)void}"

			for pkg in ${(O)FAILED_PACKAGES}; do
				local parts=("${(s:;:)pkg}")

				if [[ -n $last_type ]] && [[ $last_type != $parts[1] ]]; then
					local len=($#last_type $#parts[1])
					local cnum=${${(On)len}[1]}
					echo "${s}${(l:$cnum::-:)txt}"
				fi


				echo -n "${y}${(r:10:)parts[1]}${n} "
				echo -n "${n}${(r:25:)parts[2]}${n} "
				echo -n "${b}${parts[3]}${n}"
				echo

				last_type=$parts[1]
			done

			echo
		} | sed 's/^/   /' | alert_box --expand --left
	fi

}

parse_arguments(){
	local commands=(all neovim packages cliboard)
	local cmd=(${(M)commands:#${1}*})

	[[ $#cmd -eq 0 ]] && SCRIPT_COMMAND="exec_help"
	[[ $#cmd -eq 1 ]] && SCRIPT_COMMAND="exec_$cmd"
	[[ $#cmd -gt 1 ]] && SCRIPT_COMMAND="exec_help"

	shift 2>/dev/null

	SCRIPT_ARGS=("$@")
}

check_if_root

parse_arguments $@

$SCRIPT_COMMAND "${SCRIPT_ARGS[@]}"

show_notifications
